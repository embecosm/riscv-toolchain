# Board specification for the SiFive Coreplex E31 Arty FPGA

# Copyright (C) 2018 Embecosm Limited.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 3 of the License, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.

# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

# Delete these functions.
rename gdbserver_gdb_load {}
rename gdb_reload {}
rename gdb_reconnect {}
rename gdb_start {}
rename mi_gdb_target_cmd {}
rename mi_gdb_target_load {}
rename mi_gdb_load {}
rename mi_gdb_start mi_gdb_start_orig
rename skip_gdbserver_tests {}

proc gdb_reload_start_target { } {
    global gdb_prompt
    global GDBSERVER

    set targetname "remote"

    for {set i 1} {$i <= 3} {incr i} {
	    send_gdb "target remote ${GDBSERVER}\n"
	    gdb_expect 10 {
	        -re "A program is being debugged already.*ill it.*y or n. $" {
	            send_gdb "y\n"
	            sleep 1
	            exp_continue
	        }
	        -re "Couldn't establish connection to remote.*$gdb_prompt $" {
	            verbose "Connection failed"
	        }
	        -re "Remote MIPS debugging.*$gdb_prompt" {
	            verbose "Set target to $targetname"
	            return 0
	        }
	        -re "Remote debugging using.*Remote communication error.*$gdb_prompt $" {
	            warning "Trying to restart OpenOCD"
	            start_openocd
	            sleep 2
	            exp_continue
	            return 0
	        }
	        -re "Remote debugging using.*warning: Target-supplied registers.*$gdb_prompt $" {
	            verbose "Set target to $targetname (via openocd)"
	            return 0
	        }
	        -re "Remote target $targetname connected to.*$gdb_prompt $" {
	            verbose "Set target to $targetname"
	            return 0
	        }
	        -re "Connected to.*$gdb_prompt $" {
	            verbose "Set target to $targetname"
	            return 0
	        }
	        -re "Ending remote.*$gdb_prompt $" { }
	        -re "Connection refused.*$gdb_prompt $" {
	            verbose "Connection refused by remote target.  Pausing, and trying again."
	            sleep 30
	            continue
	        }
	        -re "Timeout reading from remote system.*$gdb_prompt $" {
	            verbose "Got timeout error from gdb."
	        }
	        -notransfer -re "Remote debugging using .*\r\n> $" {
	            # We got an unexpected prompt while creating the target.
	            # Leave it there for the test to diagnose.
	            return 1
	        }
	        timeout {
	        	# try again in two seconds
				sleep 2
				continue
	        }
	    }
    }


    return 1
}

proc monitor_reset_halt { } {
    global gdb_prompt

    send_gdb "monitor reset halt\n"
    gdb_expect 10 {
        -re "JTAG tap.*$gdb_prompt" {
            verbose "Resetting and halting the target" 2
        }
        timeout {
            warning "Couldn't reset and halt the target."
            return -1
        }
    }

    return 0
}

proc start_openocd { } {
    global env
    global openocd_pid
    global gdb_test_file_name
    
    warning "Restarting OpenOCD..."

    if [info exists openocd_pid] {
        if [catch {close -i $openocd_pid}] {
            warning "openocd_close: failed to close $openocd_pid"
        }

        if [catch {wait -i $openocd_pid}] {
            warning "openocd_close: failed to wait for $openocd_pid"
        }
    }


    set timestamp [timestamp -format "%m-%d-%Y:%H:%M:%S"]
    spawn $env(DEJAGNU_OPENOCD) -f $env(DEJAGNU_OPENOCD_CFG) --log_output $env(DEJAGNU_RESULTS_DIR)/openocd-$gdb_test_file_name-$timestamp.log
    set openocd_pid $spawn_id

    sleep 0.1
}

proc killall_openocd { } {
    set runcmd [list exec killall -q openocd]
    set status [catch {exec $runcmd} result]
    if {$status < 0 || $status > 1} {
        error "Failed to run command $runcmd: $res"
    }
    warning "Killing all running openocd processes"
}

proc gdb_reload { } {
    global gdb_prompt

    if [gdb_reload_start_target] {
        return 1
    }
    monitor_reset_halt
    gdb_load_cmd
}

proc gdb_start { } {
    global gdb_prompt

    start_openocd

    if [default_gdb_start] {
        return -1
    }

    # this board only has 2 hardware breakpoints
    send_gdb "set remote hardware-breakpoint-limit 4\n"
    gdb_expect 10 {
    -re "$gdb_prompt $" {
        verbose "Setting hardware-breakpoint-limit to 4" 2
    }
    timeout {
        warning "Couldn't set the hardware-breakpoint-limit to 4."
            return -1
        }
    }

    send_gdb "set remote hardware-watchpoint-limit 2\n"
    gdb_expect 10 {
	-re "$gdb_prompt $" {
	    verbose "Setting hardware-watchpoint-limit to 2" 2
	}
	timeout {
	    warning "Couldn't set the hardware-watchpoint-limit to 2."
            return -1
	}
    }

    return 0
}

proc mi_gdb_start { args } {
    start_openocd

    if [mi_gdb_start_orig args] {
        return -1
    }

    return 0
}

proc mi_gdb_target_cmd { protocol options } {
    global mi_gdb_prompt
    global GDBSERVER

    if [target_info exists gdb_load_timeout] {
	set loadtimeout [target_info gdb_load_timeout]
    } else {
	set loadtimeout 1600
    }


    send_gdb "47-target-select remote ${GDBSERVER}\n"
    gdb_expect 10 {
        -re "47\\^connected.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to connect to remote target (timeout)"
            return -1
        }
    }

    send_gdb "48-gdb-set remote hardware-watchpoint-limit 2\n"
    gdb_expect 10 {
        -re "48\\^done.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to set hardware-watchpoint-limit to 2."
            return -1
        }
    }

    return 0
}

#
# connect to the target and download a file, if necessary.
# return a -1 if anything goes wrong.
#
proc mi_gdb_target_load { } {
    global mi_gdb_prompt
    global GDBSERVER

    if [target_info exists gdb_load_timeout] {
    set loadtimeout [target_info gdb_load_timeout]
    } else {
    set loadtimeout 1600
    }

    send_gdb "47-target-select remote ${GDBSERVER}\n"
    gdb_expect 10 {
        -re "47\\^connected.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to connect to remote target (timeout)"
            return -1
        }
    }

    send_gdb "48-gdb-set remote hardware-watchpoint-limit 2\n"
    gdb_expect 10 {
        -re "48\\^done.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to set hardware-watchpoint-limit to 2."
            return -1
        }
    }

    send_gdb "1000-interpreter-exec console \"monitor reset halt\"\n"
    gdb_expect 10 {
        -re "1000\\^done.*$mi_gdb_prompt" {
            verbose "Resetting and halting the target" 2
        }
        timeout {
            warning "Couldn't reset and halt the target."
            return -1
        }
    }

    send_gdb "48-target-download\n"
    gdb_expect 60 {
        -re "48\\^done.*$mi_gdb_prompt$" {
        }
        timeout {
        perror "Unable to download to remote target (timeout)"
        return -1
        }
    }
    
    return 0
}

proc mi_gdb_load { arg } {
    # This is what the default does.
    if { $arg != "" } {
        mi_gdb_file_cmd $arg
    }

    mi_gdb_target_load
}

proc skip_gdbserver_tests { } {
    return 1
}
