# Board specification for the SiFive Coreplex E51 Arty FPGA

# Copyright (C) 2018 Embecosm Limited.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 3 of the License, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.

# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

# Delete these functions.
rename gdbserver_gdb_load {}
rename gdb_reload {}
rename gdb_reconnect {}
rename gdb_start {}
rename mi_gdb_target_cmd {}
rename mi_gdb_target_load {}
rename mi_gdb_load {}
rename mi_gdb_start mi_gdb_start_orig
rename skip_gdbserver_tests {}

proc gdb_reload_start_target { } {
    global gdb_prompt
    global GDBSERVER

    set targetname "remote"
    send_gdb "target remote | ${GDBSERVER}\n"
    gdb_expect 60 {
        -re "A program is being debugged already.*ill it.*y or n. $" {
            send_gdb "y\n"
            exp_continue
        }
        -re "Couldn't establish connection to remote.*$gdb_prompt $" {
            verbose "Connection failed"
        }
        -re "Remote MIPS debugging.*$gdb_prompt" {
            verbose "Set target to $targetname"
            return 0
        }
        -re "Remote debugging using.*$gdb_prompt $" {
            verbose "Set target to $targetname (via openocd)"
            return 0
        }
        -re "Remote target $targetname connected to.*$gdb_prompt $" {
            verbose "Set target to $targetname"
            return 0
        }
        -re "Connected to.*$gdb_prompt $" {
            verbose "Set target to $targetname"
            return 0
        }
        -re "Ending remote.*$gdb_prompt $" { }
        -re "Connection refused.*$gdb_prompt $" {
            verbose "Connection refused by remote target.  Pausing, and trying again."
            sleep 30
            continue
        }
        -re "Timeout reading from remote system.*$gdb_prompt $" {
            verbose "Got timeout error from gdb."
        }
        -notransfer -re "Remote debugging using .*\r\n> $" {
            # We got an unexpected prompt while creating the target.
            # Leave it there for the test to diagnose.
            return 1
        }
        timeout {
            send_gdb ""
            return 1
        }
    }

    return 1
}

proc monitor_reset_halt { } {
    global gdb_prompt

    send_gdb "monitor reset halt\n"
    gdb_expect 10 {
        -re "JTAG tap.*$gdb_prompt" {
            verbose "Resetting and halting the target" 2
        }
        timeout {
            warning "Couldn't reset and halt the target."
            return -1
        }
    }

    return 0
}

proc monitor_flash_protect_off { } {
    global gdb_prompt

    send_gdb "monitor flash protect 0 64 last off\n"
    gdb_expect 10 {
        -re "cleared protection for sectors 64 through 255 on flash bank 0.*$gdb_prompt" {
            verbose "Clearing flash protection" 2
        }
        timeout {
            warning "Couldn't clear flash protection."
            return -1
        }
    }

    return 0
}

proc killall_openocd { } {
    set runcmd [list exec killall -q openocd]
    set status [catch {exec $runcmd} result]
    if {$status < 0 || $status > 1} {
        error "Failed to run command $runcmd: $res"
    }
    warning "Killing all running openocd processes"
}

proc gdb_reload { } {
    global gdb_prompt

    if [gdb_reload_start_target] {
        return 1
    }
    monitor_reset_halt
    monitor_flash_protect_off
    gdb_load_cmd
    
}

proc gdb_start { } {
    global gdb_prompt

    killall_openocd
    
    if [default_gdb_start] {
        return -1
    }

    # this board only has 2 hardware breakpoints
    send_gdb "set remote hardware-breakpoint-limit 4\n"
    gdb_expect 10 {
    -re "$gdb_prompt $" {
        verbose "Setting hardware-breakpoint-limit to 4" 2
    }
    timeout {
        warning "Couldn't set the hardware-breakpoint-limit to 4."
            return -1
        }
    }

    send_gdb "set remote hardware-watchpoint-limit 4\n"
    gdb_expect 10 {
	-re "$gdb_prompt $" {
	    verbose "Setting hardware-watchpoint-limit to 4" 2
	}
	timeout {
	    warning "Couldn't set the hardware-watchpoint-limit to 4."
            return -1
	}
    }

    return 0
}

proc mi_gdb_start { args } {
    killall_openocd

    if [mi_gdb_start_orig args] {
        return -1
    }

    return 0
}

proc mi_gdb_target_cmd { protocol options } {
    global mi_gdb_prompt
    global GDBSERVER

    if [target_info exists gdb_load_timeout] {
	set loadtimeout [target_info gdb_load_timeout]
    } else {
	set loadtimeout 1600
    }

    send_gdb "47-target-select remote | ${GDBSERVER}\n"
    gdb_expect 60 {
        -re "47\\^connected.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to connect to remote target (timeout)"
            return -1
        }
    }

    send_gdb "48-gdb-set remote hardware-watchpoint-limit 4\n"
    gdb_expect 10 {
        -re "48\\^done.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to set hardware-watchpoint-limit to 4."
            return -1
        }
    }

    return 0
}

#
# connect to the target and download a file, if necessary.
# return a -1 if anything goes wrong.
#
proc mi_gdb_target_load { } {
    global mi_gdb_prompt
    global GDBSERVER

    if [target_info exists gdb_load_timeout] {
    set loadtimeout [target_info gdb_load_timeout]
    } else {
    set loadtimeout 1600
    }

    send_gdb "47-target-select remote | ${GDBSERVER}\n"
    gdb_expect 60 {
        -re "47\\^connected.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to connect to remote target (timeout)"
            return -1
        }
    }

    send_gdb "48-gdb-set remote hardware-watchpoint-limit 4\n"
    gdb_expect 10 {
        -re "48\\^done.*$mi_gdb_prompt" {
        }
        timeout {
            perror "Unable to set hardware-watchpoint-limit to 4."
            return -1
        }
    }

    send_gdb "1000-interpreter-exec console \"monitor reset halt\"\n"
    gdb_expect 10 {
        -re "1000\\^done.*$mi_gdb_prompt" {
            verbose "Resetting and halting the target" 2
        }
        timeout {
            warning "Couldn't reset and halt the target."
            return -1
        }
    }

    send_gdb "1001-interpreter-exec console \"monitor flash protect 0 64 last off\"\n"
    gdb_expect 10 {
        -re "1001\\^done.*$mi_gdb_prompt" {
            verbose "Clearing flash protection" 2
        }
        timeout {
            warning "Couldn't clear flash protection."
            return -1
        }
    }

    send_gdb "48-target-download\n"
    gdb_expect 60 {
        -re "48\\^done.*$mi_gdb_prompt$" {
        }
        timeout {
        perror "Unable to download to remote target (timeout)"
        return -1
        }
    }
    
    return 0
}

proc mi_gdb_load { arg } {
    # This is what the default does.
    if { $arg != "" } {
        mi_gdb_file_cmd $arg
    }

    mi_gdb_target_load
}

proc skip_gdbserver_tests { } {
    return 1
}
